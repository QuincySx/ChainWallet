std::vector<uint8_t> createPrivateKey();

std::vector<uint8_t> createPrivateKey() {
    //get epoch time
    unsigned seed1 = std::chrono::system_clock::now().time_since_epoch().count();

    //generate random number for priv key
    std::seed_seq seed{seed1};
    std::mt19937_64 eng(seed);
    std::string randString;
    for (int i = 0; i < 10; ++i) {
        randString += eng();
    }

    //generate SHA-256 (our priv key)
    std::vector<uint8_t> out;
    out.resize(32);
    sha256_Raw(reinterpret_cast<const uint8_t *>(randString.c_str()), randString.length(), &out[0]);

    assert(out.size() == 32);

    std::vector<uint8_t> privKey = std::move(out);
    if (verifyKey(privKey)) {
        return privKey;
    } else {
        return std::vector<uint8_t>();
    }
}

/**
 * @brief creates private key and returns it in uncompressed form
 * @param env
 * @param byteObj
 * @param privKeyBytes
 * @return public key byte[]
 */
JNIEXPORT jbyteArray JNICALL
Java_com_smallraw_chain_lib_jni_Secp256k1JNI_createPrivateKey(JNIEnv *env,
                                                              jobject byteObj /* this */) {
    std::vector<uint8_t> priv = createPrivateKey();
    unsigned char *pvKey = priv.data();
    auto size = priv.size();
    jbyteArray ret = env->NewByteArray(size);
    env->SetByteArrayRegion(ret, 0, size, (jbyte *) pvKey);
    return ret;
}




----------------------------
std::string base16Decode(const std::string &input);

std::string base16Encode(const std::string &input);




static int hexValue(char hex_digit) {
    switch (hex_digit) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            return hex_digit - '0';

        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
            return hex_digit - 'A' + 10;

        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
            return hex_digit - 'a' + 10;
    }
    throw std::invalid_argument("bad hex_digit");
}

std::string base16Decode(const std::string &input) {
    const auto len = input.length();
    if (len & 1) {
        return "";
    }

    std::string output;
    output.reserve(len / 2);
    for (auto it = input.begin(); it != input.end();) {
        try {
            int hi = hexValue(*it++);
            int lo = hexValue(*it++);
            output.push_back(hi << 4 | lo);
        } catch (const std::invalid_argument &e) {
            throw e;
        }
    }
    return output;
}

std::string base16Encode(const std::string &input) {
    static constexpr char hex_digits[] = "0123456789abcdef";

    std::string output;
    output.reserve(input.length() * 2);
    for (unsigned char c : input) {
        output.push_back(hex_digits[c >> 4]);
        output.push_back(hex_digits[c & 15]);
    }
    return output;
}



/**
* @brief takes hex string and converts to byte array
* @param env
* @param str hex string
* @return byte array
*/
JNIEXPORT jbyteArray JNICALL
Java_com_smallraw_chain_lib_jni_Secp256k1JNI_hexToBytes(JNIEnv *env, jobject obj,
                                                        jstring str) {
    const char *javaString = env->GetStringUTFChars(str, nullptr);
    auto byteString = base16Decode(javaString);
    jbyteArray ret = env->NewByteArray(byteString.length());
    env->SetByteArrayRegion(ret, 0, byteString.length(), (const jbyte *) byteString.c_str());

    return ret;
}

JNIEXPORT jstring JNICALL
Java_com_smallraw_chain_lib_jni_Secp256k1JNI_bytesToHex(JNIEnv *env, jobject bytesObj,
                                                        jbyteArray b, jint size) {
    const unsigned char *bytes = (const unsigned char *) env->GetByteArrayElements(b, nullptr);
//    const unsigned char * bytes  = (const unsigned char*)env->GetDirectBufferAddress(b);
    auto byteString = base16Encode((const char *) bytes);
    byteString.resize(size * 2);
    assert (byteString.size() == size * 2);
    return env->NewStringUTF(byteString.c_str());
}

